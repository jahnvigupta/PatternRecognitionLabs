# -*- coding: utf-8 -*-
"""pca.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1czLPCu8GCYirFU1aRGBX2urRnw_lAHSl
"""

!pip install python-mnist

import skimage
import matplotlib.pyplot as plt
import numpy as np
from numpy import linalg as LA
from keras.datasets import mnist
from matplotlib import pyplot

#returns sorted eigen values and corresponding eigen vectors
def sorted_eig(A):   
    lambdas, vs = LA.eig(A)
    lambdas, vs = zip(*sorted(zip(list(lambdas), list(vs.T)),key=lambda x: x[0], reverse=True))
    return lambdas, np.array(vs).T

#Function to add noise
def add_noise(img):
  return skimage.util.random_noise(img, mode='gaussian', var=0.15)

#n_com is number of components
#returns energy of data, projected features, reconstructed image
def pca(n_com, data):
  digits_cov = np.cov(data.T)
  lambdas, vs = sorted_eig(np.array(digits_cov))
  energy = 0
  for i in range(n_com):
    energy = energy+pow(lambdas[i],2)
  W = vs[:,0:n_com]
  proj_digits = np.matmul(data, W)
  reconstructed = np.matmul(proj_digits, W.T)
  return energy, proj_digits, reconstructed

# load dataset
(trainX, trainy), (testX, testy) = mnist.load_data()

#Array to store flattened images
train_data = np.zeros((len(trainX),28*28))
test_data = np.zeros((len(testX),28*28))

#Storing flattened images
for i in range(len(trainX)):
  train_data[i] = trainX[i].flatten()
for i in range(len(testX)):
  test_data[i] = testX[i].flatten()

#Calculating energy for different components and plotting energy
energy = []
x = []
for i in range(70):
  energy.append(pca(i, train_data)[0])
  x.append(i)
plt.plot(x,energy)

#Showing reconstructed and original images
for i in range(2):
  plt.figure()
  plt.imshow(test_data[i].reshape(28,28))
  plt.figure()
  plt.imshow(pca(30, test_data)[2][i].reshape(28,28))

#Adding noise to images
test_noise = np.zeros((len(testX),28,28))
train_noise = np.zeros((len(trainX),28,28))

for i in range(len(trainX)):
  train_noise[i] = add_noise(trainX[i])

for i in range(len(testX)):
  test_noise[i] = add_noise(testX[i])

train_data_noise = np.zeros((len(trainX),28*28))
test_data_noise = np.zeros((len(testX),28*28))

for i in range(len(trainX)):
  train_data_noise[i] = train_noise[i].flatten()
for i in range(len(testX)):
  test_data_noise[i] = test_noise[i].flatten()

#Plotting energy images with nois
energy_noise = []
x_noise = []
for i in range(70):
  energy_noise.append(pca(i, train_data_noise)[0])
  x_noise.append(i)

plt.plot(x_noise,energy_noise)

#Showing orinal and reconstructed images with noise
for i in range(2):
  plt.figure()
  plt.imshow(test_data_noise[i].reshape(28,28))
  plt.figure()
  plt.imshow(pca(70, test_data_noise)[2][i].reshape(28,28))